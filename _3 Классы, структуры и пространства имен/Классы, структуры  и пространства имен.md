# Классы, структуры и пространства имен

## Классы и объекты

C# является полноценным объектно-ориентированным языком. Это значит, что программу на C# можно представить в виде взаимосвязанных взаимодействующих между собой объектов.

Описанием объекта является **класс**, а объект представляет экземпляр этого класса. Можно еще провести следующую аналогию. У нас у всех есть некоторое представление о человеке, у которого есть имя, возраст, какие-то другие характеристики. То есть некоторый шаблон - этот шаблон можно назвать классом. Конкретное воплощение этого шаблона может отличаться, например, одни люди имеют одно имя, другие - другое имя. И реально существующий человек (фактически экземпляр данного класса) будет представлять объект этого класса.

В принципе ранее уже использовались классы. Например, тип ```string```, который представляет строку, фактически является классом. Или, например, класс ```Console```, у которого метод ```WriteLine()``` выводит на консоль некоторую информацию. Теперь же посмотрим, как мы можем определять свои собственные классы.

По сути класс представляет новый тип, который определяется пользователем. Класс определяется с помощью ключевого слова **сlass**:

```Csharp
class название_класса
{
    // содержимое класса
}
```

После слова **class** идет имя класса и далее в фигурных скобках идет собственно содержимое класса. Например, определим в файле ```Program.cs``` класс Person, который будет представлять человека:

```Csharp
class Person
{
  
}
```

![](https://metanit.com/sharp/tutorial/pics/3.25.png)

Однако такой класс не особо показателен, поэтому добавим в него некоторую функциональность.

## Поля и методы класса

Класс может хранить некоторые данные. Для хранения данных в классе применяются **поля**. По сути **поля класса** - это переменные, определенные на уровне класса.

Кроме того, класс может определять некоторое поведение или выполняемые действия. Для определения поведения в классе применяются методы.

Итак, добавим в класс Person поля и методы:

```Csharp
class Person 
{
    public string name = "Undefined";   // имя
    public int age;                     // возраст
 
    public void Print()
    {
        Console.WriteLine($"Имя: {name}  Возраст: {age}");
    }
}
```

В данном случае в классе Person определено поле name, которое хранит имя, и поле age, которое хранит возраст человека. В отличие от переменных, определенных в методах, поля класса могут иметь модификаторы, которые указываются перед полем. Так, в данном случае, чтобы все поля были доступны вне класса Person поля определены с модификатором **public**.

При определении полей мы можем присвоить им некоторые значения, как в примере выше в случае переменной ```name```. Если поля класса не инициализированы, то они получают значения по умолчанию. Для переменных числовых типов это число 0.

Также в классе ```Person``` определен метод ```Print()```. Методы класса имеют доступ к его поля, и в данном случае обращаемся к полям класса ```name``` и ```age``` для вывода их значения на консоль. И чтобы этот метод был виден вне класса, он также определен с модификатором **public**.

## Создание объекта класса  

После определения класса мы можем создавать его объекты. Для создания объекта применяются **конструкторы**. По сути конструкторы представляют специальные методы, которые называются так же как и класс, и которые вызываются при создании нового объекта класса и выполняют инициализацию объекта. Общий синтаксис вызова конструктора:

```Csharp
new конструктор_класса(параметры_конструктора);
```

Сначала идет оператор ```new```, который выделяет память для объекта, а после него идет вызов **конструктора**.

## Конструктор по умолчанию

Если в классе не определено ни одного конструктора (как в случае с нашим классом Person), то для этого класса автоматически создается пустой конструктор по умолчанию, который не принимает никаких параметров.

Теперь создадим объект класса Person:

```Csharp
Person tom = new Person();  // создание объекта класса Person
 
// определение класса Person
class Person 
{
    public string name = "Undefined";
    public int age;
 
    public void Print()
    {
        Console.WriteLine($"Имя: {name}  Возраст: {age}");
    }
}
```

Для создания объекта ```Person``` используется выражение new ```Person()```. В итоге после выполнения данного выражения в памяти будет выделен участок, где будут храниться все данные объекта ```Person```. А переменная ```tom``` получит ссылку на созданный объект, и через эту переменную мы можем использовать данный объект и обращаться к его функциональности.

## Обращение к функциональности класса

Для обращения к функциональности класса - полям, методам (а также другим элементам класса) применяется точечная нотация точки - после объекта класса ставится точка, а затем элемент класса:

```Csharp
объект.поле_класса
объект.метод_класса(параметры_метода)
```

Например, обратимся к полям и методам объекта ```Person```:


```Csharp
Person tom = new Person();  // создание объекта класса Person
 
// Получаем значение полей в переменные
string personName = tom.name;
int personAge = tom.age;
Console.WriteLine($"Имя: {personName}  Возраст {personAge}");   // Имя: Undefined  Возраст: 0
 
// устанавливаем новые значения полей
tom.name = "Tom";
tom.age = 37;
 
// обращаемся к методу Print
tom.Print();    // Имя: Tom  Возраст: 37
 
class Person 
{
    public string name = "Undefined";
    public int age;
 
    public void Print()
    {
        Console.WriteLine($"Имя: {name}  Возраст: {age}");
    }
}
```

Консольный вывод данной программы:  

```
Имя: Undefined	Возраст: 0
Имя: Tom	Возраст: 37
```

## Константы классы

Кроме полей класс может определять для хранения данных константы. В отличие от полей из значение устанавливается один раз непосредственно при их объявлении и впоследствии не может быть изменено. Кроме того, константы хранят некоторые данные, которые относятся не к одному объекту, а ко всему классу в целом. И для обращения к константам применяется не имя объекта, а имя класса:

```Csharp
Person tom = new Person();
tom.name = "Tom";
tom.age = 37;
tom.Print();    // Person: Tom - 37
 
Console.WriteLine(Person.type); // Person
// Person.type = "User";    // !Ошибка: изменить константу нельзя
 
class Person
{
    public const string type = "Person";
    public string name = "Undefined";
    public int age;
    public void Print() => Console.WriteLine($"{type}: {name} - {age}");
}
```

Здесь в классе ```Person``` определена константа ```type```, которая хранит название класса:

```Csharp
public const string type = "Person";
```

Название класса не зависит от объекта. Мы можем создать много объектов ```Person```, но название класса от этого не должно измениться - оно относится ко всем объектам Person и не должно меняться. Поэтому название типа можно сохранить в виде константы.

Стоит отметить, что константе сразу при ее определении необходимо присвоить значение.

Подобно обычным полям мы можем обращаться к константам класса внутри этого класса. Например, в методе ```Print``` значение константы выводится на консоль.

Однако если мы хотим обратиться к константе вне ее класса, то для обращения необходимо использовались имя класса:

```Csharp
Console.WriteLine(Person.type); // Person
```

Таким образом, если необходимо хранить данные, которые относятся ко всему классу в целом, то можно использовать константы.

## Добавление класса в Visual Studio

Обычно классы помещаются в отдельные файлы. Нередко для одного класса предназначен один файл. И Visual Studio предоставляет по умолчанию встроенные шаблоны для добвления класса.

Для добавления класса нажмем в Visual Studio правой кнопкой мыши на название проекта:

![](https://metanit.com/sharp/tutorial/pics/3.39.png)

В появившемся контекстном меню выберем пункт **Add -> New Item... (или Add -> Class...)**

В открывшемся окне добавления нового элемента убедимся, что в центральной части с шаблонами элементов у нас выбран пункт **Class**. А внизу окна в поле **Name** введем название добавляемого класса - пусть он будет назваться **Person**:

![](https://metanit.com/sharp/tutorial/pics/3.40.png)

В качестве названия класса можно вводить как Person, так и Person.cs. И после нажатия на кнопку добавления в проект будет добавлен новый класс:

![](https://metanit.com/sharp/tutorial/pics/3.41.png)

В файле Person.cs определим следующий код:

```Csharp
class Person
{
    public string name = "Undefined";
    public void Print()
    {
        Console.WriteLine($"Person {name}");
    }
}
```

Здесь определен класс ```Person``` с одним полем name и методом ```Print```

В файле ```Program.cs```, который представляет основной файл программы используем класс ```Person```:

![](https://metanit.com/sharp/tutorial/pics/3.42.png)

Таким образом, мы можем определять классы в отдельных файлах и использовать их в программе.






# Конструкторы, инициализаторы и деконструкторы

## Создание конструкторов

Выше для создания объекта использовался конструктор по умолчанию. Однако мы сами можем определить свои конструкторы. Как правило, конструктор выполняет инициализацию объекта. При этом если в классе определяются свои конструкторы, то он лишается конструктора по умолчанию.

На уровне кода конструктор представляет метод, который называется по имени класса, который может иметь параметры, но для него не надо определять возвращаемый тип. Например, определим в классе ```Person``` простейший конструктор:

```Csharp
Person tom = new Person();  // Создание объекта класса Person
 
tom.Print();    // Имя: Tom  Возраст: 37
 
class Person 
{
    public string name;
    public int age;

    public Person()
    {
        Console.WriteLine("Создание объекта Person");
        name = "Tom";
        age = 37;
    }
    public void Print()
    {
        Console.WriteLine($"Имя: {name}  Возраст: {age}");
    }
}
```

Итак, здесь определен конструктор, который выводит на консоль некоторое сообщение и инициализирует поля класса.


```Csharp
public Person()
{
    Console.WriteLine("Создание объекта Person");
    name = "Tom";
    age = 37;
}
```

Конструкторы могут иметь модификаторы, которые указываются перед именем конструктора. Так, в данном случае, чтобы конструктор был доступен вне класса Person, он определен с модификатором ```public```.

Определив конструктор, мы можем вызвать его для создания объекта ```Person```:

```Csharp
Person tom = new Person();  // Создание объекта Person
```

В данном случае выражение ```Person()``` как раз представляет вызов определенного в классе конструктора (это больше не автоматический конструктор по умолчанию, которого у класса теперь нет). Соответственно при его выполнении на консоли будет выводиться строка "Создание объекта Person"

Подобным образом мы можем определять и другие конструкторы в классе. Например, изменим класс ```Person``` следующим образом:

```Csharp
Person tom = new Person();          // вызов 1-ого конструктора без параметров
Person bob = new Person("Bob");     //вызов 2-ого конструктора с одним параметром
Person sam = new Person("Sam", 25); // вызов 3-его конструктора с двумя параметрами
 
tom.Print();          // Имя: Неизвестно  Возраст: 18
bob.Print();          // Имя: Bob  Возраст: 18
sam.Print();          // Имя: Sam  Возраст: 25
 
class Person 
{
    public string name;
    public int age;
    public Person() { name = "Неизвестно"; age = 18; }      // 1 конструктор
    public Person(string n) { name = n; age = 18; }         // 2 конструктор
    public Person(string n, int a) { name = n; age = a; }   // 3 конструктор
 
    public void Print()
    {
        Console.WriteLine($"Имя: {name}  Возраст: {age}");
    }
}
```

Теперь в классе определено три конструктора, каждый из которых принимает различное количество параметров и устанавливает значения полей класса. И мы можем вызвать один из этих конструкторов для создания объекта класса.

Консольный вывод данной программы:

```
Имя: Неизвестно  Возраст: 18
Имя: Bob  Возраст: 18
Имя: Sam  Возраст: 25
```

Стоит отметить, что начиная с версии **C# 9** мы можем сократить вызов конструктора, убрав из него название типа:

```Csharp
Person tom = new ();            // аналогично new Person();
Person bob = new ("Bob");       // аналогично new Person("Bob");
Person sam = new ("Sam", 25);   // аналогично new Person("Sam", 25);
```

## Ключевое слово this

Ключевое слово **this** представляет ссылку на текущий экземпляр/объект класса. В каких ситуациях оно нам может пригодиться?

```Csharp
Person sam = new("Sam", 25); 
sam.Print();          // Имя: Sam  Возраст: 25
 
class Person 
{
    public string name;
    public int age;
    public Person() { name = "Неизвестно"; age = 18; }
    public Person(string name) { this.name = name; age = 18; }
    public Person(string name, int age) 
    { 
        this.name = name; 
        this.age = age; 
    }
    public void Print() => Console.WriteLine($"Имя: {name}  Возраст: {age}");
}
```

В примере выше во втором и третьем конструкторе параметры называются также, как и поля класса. И чтобы разграничить параметры и поля класса, к полям класса обращение идет через ключевое слово this. Так, в выражении

```Csharp
this.name = name;
```

первая часть - this.name означает, что name - это поле текущего класса, а не название параметра name. Если бы у нас параметры и поля назывались по-разному, то использовать слово this было бы необязательно. Также через ключевое слово **this** можно обращаться к любому полю или методу.

## Цепочка вызова конструкторов

В примере выше определены три конструктора. Все три конструктора выполняют однотипные действия - устанавливают значения полей name и age. Но этих повторяющихся действий могло быть больше. И мы можем не дублировать функциональность конструкторов, а просто обращаться из одного конструктора к другому также через ключевое слово this, передавая нужные значения для параметров:

```Csharp
class Person 
{
    public string name;
    public int age;
    public Person() : this("Неизвестно")    // первый конструктор
    { }
    public Person(string name) : this(name, 18) // второй конструктор
    { }
    public Person(string name, int age)     // третий конструктор
    {
        this.name = name;
        this.age = age;
    }
    public void Print() => Console.WriteLine($"Имя: {name}  Возраст: {age}");
}
```

В данном случае первый конструктор вызывает второй, а второй конструктор вызывает третий. По количеству и типу параметров компилятор узнает, какой именно конструктор вызывается. Например, во втором конструкторе:

```Csharp
public Person(string name) : this(name, 18)
{ }
```

идет обращение к третьему конструктору, которому передаются два значения. Причем в начале будет выполняться именно третий конструктор, и только потом код второго конструктора.

Стоит отметить, что в примере выше фактически все конструкторы не определяют каких-то других действий, кроме как передают третьему конструктору некоторые значения. Поэтому в реальности в данном случае проще оставить один конструктор, определив для его параметров значения по умолчанию:

```Csharp
Person tom = new();
Person bob = new("Bob");
Person sam = new("Sam", 25);
 
tom.Print();          // Имя: Неизвестно  Возраст: 18
bob.Print();          // Имя: Bob  Возраст: 18
sam.Print();          // Имя: Sam  Возраст: 25
 
class Person 
{
    public string name;
    public int age;
    public Person(string name = "Неизвестно", int age = 18)
    {
        this.name = name;
        this.age = age;
    }
    public void Print() => Console.WriteLine($"Имя: {name}  Возраст: {age}");
}
```
И если при вызове конструктора мы не передаем значение для какого-то параметра, то применяется значение по умолчанию.

## Инициализаторы объектов

Для инициализации объектов классов можно применять **инициализаторы**. Инициализаторы представляют передачу в фигурных скобках значений доступным полям и свойствам объекта:

```Csharp
Person tom = new Person { name = "Tom", age = 31 };
// или так
// Person tom = new() { name = "Tom", age = 31 };
tom.Print();          // Имя: Tom  Возраст: 31
```

С помощью инициализатора объектов можно присваивать значения всем доступным полям и свойствам объекта в момент создания. При использовании инициализаторов следует учитывать следующие моменты:

- С помощью инициализатора мы можем установить значения только доступных из вне класса полей и свойств объекта. Например, в примере выше поля name и age имеют модификатор доступа public, поэтому они доступны из любой части программы.

- Инициализатор выполняется после конструктора, поэтому если и в конструкторе, и в инициализаторе устанавливаются значения одних и тех же полей и свойств, то значения, устанавливаемые в конструкторе, заменяются значениями из инициализатора.

Инициализаторы удобно применять, когда поле или свойство класса представляет другой класс:

```Csharp
Person tom = new Person{ name = "Tom", company = { title = "Microsoft"} };
tom.Print();          // Имя: Tom  Компания: Microsoft
 
class Person
{
    public string name;
    public Company company;
    public Person() 
    { 
        name = "Undefined";
        company = new Company();
    }
    public void Print() => Console.WriteLine($"Имя: {name}  Компания: {company.title}");
}
 
class Company
{
    public string title = "Unknown";
}
```

Обратите внимание, как устанавливается поле company:

```Csharp
company = { title = "Microsoft"}
```

## Деконструкторы

Деконструкторы (не путать с деструкторами) позволяют выполнить декомпозицию объекта на отдельные части.

Например, пусть у нас есть следующий класс ```Person```:

```Csharp
class Person
{
    string name;
    int age;
    public Person(string name, int age)
    {
        this.name = name;
        this.age = age;
    }
 
    public void Deconstruct(out string personName, out int personAge)
    {
        personName = name;
        personAge = age;
    }
}
```

В этом случае мы могли бы выполнить декомпозицию объекта ```Person``` так:

```Csharp
Person person = new Person("Tom", 33);
 
(string name, int age) = person;
 
Console.WriteLine(name);    // Tom
Console.WriteLine(age);     // 33
```

Значения переменным из деконструктора передаюся по позиции. То есть первое возвращаемое значение в виде параметра personName передается первой переменной - name, второе возващаемое значение - переменной age.

По сути деконструкторы это не более,чем синтаксический сахар. Это все равно, что если бы мы написали:

```Csharp
Person person = new Person("Tom", 33);
 
string name; int age;
person.Deconstruct(out name, out age);
```
При получении значений из декоструктора нам необходимо предоставить столько переменных, сколько деконструктор возвращает значений. Однако бывает, что не все эти значения нужны. И вместо возвращаемых значений мы можем использовать прочерк ```_```. Например, нам надо получить только возраст пользователя:

```Csharp
Person person = new Person("Tom", 33);
 
(_, int age) = person;
 
Console.WriteLine(age);    // 33
```

Поскольку первое возвращаемое значение - это имя пользователя, которое не нужно, в в данном случае вместо переменной прочерк.





# Класс Program и метод Main. Программы верхнего уровня

Точкой входа в программу на языке C# является метод ```Main```. Именно с этого метода начинается выполнение программы на C#. И программа на C# должна обязательно иметь метод ```Main```. Однако может возникнуть вопрос, какой еще метод ```Main```, если, например, Visual Studio 2022 по умолчанию создает проект консольного приложения со следующим кодом:

```Csharp
// See https://aka.ms/new-console-template for more information
Console.WriteLine("Hello, World!");
```

И эта программа никаких методов ```Main``` не содержит, но при этом нормально выполняется и выводит на консоль строку "Hello, World!", как и запланировано. Это так называемая программа верхнего уровня (top-level program). А вызов Console.WriteLine("Hello, World!") представляет инструкцию вехнего уровня (top-level statement).

Однако в реальности этот код неявно помещается компилятором в метод ```Main```, который, в свою очередь, помещается в класс ```Program```. В действительности название класса может быть любым (как правило, это класс ```Program```, собственно поэтому генерируемый по умолчанию файл кода называется ```Program.cs```). Но метод ```Main``` является обязательной частью консольного приложения. Поэтому выше представленный код фактически эквивалентен следующей программе:

```Csharp
class Program
{
    static void Main(string[] args)
    {
        // See https://aka.ms/new-console-template for more information
        Console.WriteLine("Hello, World!");
    }
}
```

Определение метода **Main** обязательно начинается с модификатора static, которое указывает, что метод Main - статический. Позже мы подробнее разберем, что все это значит.

Возвращаемым типом метода **Main** обязательно является тип **void**. Кроме того, в качестве параметра он принимает массив строк - ```string[] args``` - в реальной программе это те параметры, через которые при запуске программы из консоли мы можем передать ей некоторые значения. Внутри метода располагаются действия, которые выполняет программа.

До Visual Studio 2022 все предыдущие студии создавали по умолчанию примерно такой код. Но начиная с Visual Studio 2022 нам необязательно вручную определять класс ```Program``` и в нем метод ```Main``` - компилятор генерирует их самостоятельно.

Если мы определяем какие-то переменные, константы, методы и обращаемся к ним, они помещаются в метод ```Main```. Например, следующая программа верхнего уровня

```Csharp
string hello = "Hello METANIT.COM";
 
Print(hello);
 
void Print(string message)
{
    Console.WriteLine(message);
}
```

будет аналогична следующей программе:

```Csharp
class Program
{
    static void Main(string[] args)
    {
        string hello = "Hello METANIT.COM";
 
        Print(hello);
 
        void Print(string message)
        {
            Console.WriteLine(message);
        }
    }
}
```

Если определяются новые типы, например, классы, то они помещаются вне класса ```Program```. Например, код:

```Csharp
Person tom = new();
tom.SayHello();
 
class Person
{ 
    public void SayHello() =>Console.WriteLine("Hello");
}
```

будет аналогичен следующему

```Csharp
class Program
{
    static void Main(string[] args)
    {
        Person tom = new();
        tom.SayHello();
    }
}
class Person
{
    public void SayHello() => Console.WriteLine("Hello");
}
```

Однако надо учитывать, что опредления типов (в частности классов) должны идти в конце файла после инструкций верхнего уровня. То есть:


```Csharp
// инструкции верхнего уровня (top-level statements)
Person tom = new();
tom.SayHello();
 
// определение класса идет после инструкций верхнего уровня
class Person
{
    public void SayHello() => Console.WriteLine("Hello");
}
```

Таким образом, мы можем продолжать писать программы верхнего уровня без явного определения метода ```Main```. Либо мы можем явным образом определить метод ```Main``` и класс ```Program```:

![](https://metanit.com/sharp/tutorial/pics/3.35.png)

И этот код будет выполняться аналогичным образом, как если бы мы не использовали класс ```Program``` и метод ```Main```.

# Структуры

Наряду с классами структуры представляют еще один способ создания собственных типов данных в C#. Более того многие примитивные типы, например, int, double и т.д., по сути являются структурами.

## Определение структуры

Для определения структуры применяется ключевое слово **struct**:

```Csharp
struct имя_структуры
{
    // элементы структуры
}
```

После слова **struct** идет название структуры и далее в фигурных скобках размещаются элементы структуры - поля, методы и т.д.

Например, определим структуру, которая будет называться ```Person``` и которая будет представлять человека:

```Csharp
struct Person
{
}   
```

Как и классы, структуры могут хранить состояние в виде полей (переменных) и определять поведение в виде методов. Например, добавим в структуру ```Person``` пару полей и метод:

```Csharp
struct Person
{
    public string name;
    public int age;
 
    public void Print()
    {
        Console.WriteLine($"Имя: {name}  Возраст: {age}");
    }
}
```
В данном случае определены две переменные - name и age для хранения соответственно имени и возраста человека и метод Print для вывода информации о человеке на консоль.

И как и в случае с классами, для обращения к функциональности структуры - полям, методам и другим компонентам структуры применяется точечная нотация - после объекта структуры ставится точка, а затем указывается компонент структуры:

```Csharp
объект.поле_структуры
объект.метод_структуры(параметры_метода)
```

## Создание объекта структуры

### Инициализация с помощью конструктора

Для использования структуры ее необходмо инициализировать. Для инициализации создания объектов структуры, как и в случае с классами, применяется вызов конструктура с оператором new. Даже если в коде стуктуры не определено ни одного конструктора, тем не менее имеет как минимум один конструктор - конструктор по умолчанию, который генерируется компилятором. Этот конструктор не принимает параметров и создает объект структуры со значениями по умолчанию.

```Csharp
new название_структуры();
```
Например, создадим объект структуры ```Person``` с помощью конструктора по умолчанию:

```Csharp
Person tom = new Person();  // вызов конструктора
// или так 
// Person tom = new();
 
tom.name = "Tom";   // изменяем значение по умолчанию в поле name
 
tom.Print();    // Имя: Tom  Возраст: 0
 
struct Person
{
    public string name;
    public int age;
 
    public void Print()
    {
        Console.WriteLine($"Имя: {name}  Возраст: {age}");
    }
}
```
В данном случае создается объект tom. Для его создания вызывается конструктор по умолчанию, который устанавливает значения по умолчанию для его полей. Для числовых данных это значение 0, поэтому поле age будет иметь значение 0. Для строк это значение null, которое указывает на отсутствие значения. Но далее, если поля доступны (а в данном случае поскольку они имеют модификатор public они доступны), мы можем измениь их значения. Так, здесь полю name присваивается строка "Tom". Соответственно при выполнении метода Print() мы получим следующий консольный вывод:

```
Имя: Tom  Возраст: 0
```

### Непосредственная иницилизация полей

Если все поля структуры доступны (как в случае с полями структуры Person, который имеют модификатор **public**), то структуру можно инициализировать без вызова конструктора. В этом случае необходимо присвоить значения всем полям структуры перед получением значений полей и обращением к методам структуры. Например:

```Csharp
Person tom;         // не вызываем конструктор
// инициализация полей
tom.name = "Sam";
tom.age = 37;
 
tom.Print();    // Имя: Sam  Возраст: 37
 
struct Person
{
    public string name;
    public int age;
 
    public void Print()
    {
        Console.WriteLine($"Имя: {name}  Возраст: {age}");
    }
}
```

## Инициализация полей по умолчанию

Стоит отметить, что начиная с версии C# 10, мы можем напрямую инициализировать поля структуры при их определении (до C# 10 это делать было нельзя):

```Csharp
Person tom = new Person();
tom.Print();    // Имя:Tom  Возраст: 1
 
struct Person
{
    // инициализация полей значениями по умолчанию - доступна с C#10
    public string name = "Tom";
    public int age = 1;
    public Person() { }
    public void Print() =>Console.WriteLine($"Имя: {name}  Возраст: {age}");
}
```
Однако даже в этом случае, несмотря на значения по умолчанию, необходимо явно определить и вызывать конструктор, если мы хотим использоват эти значения.

## Конструкторы структуры

Как и класс, структура может определять конструкторы. Однако, если в структуре определяется конструктор, то в нем обязательно надо инициализировать все поля структуры.

Например, добавим в структуру ```Person``` конструктор:


```Csharp
Person tom = new();
Person bob = new("Bob");
Person sam = new("Sam", 25);
 
tom.Print();    // !!!! Имя:   Возраст: 0
bob.Print();    // Имя: Bob  Возраст: 1 
sam.Print();    // Имя: Sam  Возраст: 25
 
struct Person
{
    public string name;
    public int age;
 
    public Person(string name = "Tom", int age = 1)
    {
        this.name = name;
        this.age = age;
    }
    public void Print() => Console.WriteLine($"Имя: {name}  Возраст: {age}");
}
```

В данном случае в структуре Person определен конструктор с двумя параметрами, для которых предоставлены значения по умолчания. Однако обратите внимание на создание первого объекта структуры:

```Csharp
Person tom = new(); // по прежнему используется конструктор без параметров по умолчанию
tom.Print();    // !!!! Имя:   Возраст: 0
```
Здесь по-прежнему применяется конструктор по умолчанию, тогда как при инициализации остальных двух переменных структуры применяется явно определенный конструктор.

Однако начиная с версии C# 10 мы можем определить свой конструктор без параметров:

```Csharp
Person tom = new();
 
tom.Print();    // Имя: Tom  Возраст: 37
 
struct Person
{
    public string name;
    public int age;
 
    public Person()
    {
        name = "Tom";
        age = 37;
    }
    public void Print() => Console.WriteLine($"Имя: {name}  Возраст: {age}");
}   
```
Опять же при определении конструктора без параметров необходимо инициализировать все поля структуры.

В случае если нам необходимо вызывать конструкторы с различным количеством параметров, то мы можем, как и в случае с классами, вызывать их по цепочке:

```Csharp
Person tom = new();
Person bob = new("Bob");
Person sam = new("Sam", 25);
 
tom.Print();    // Имя: Tom  Возраст: 1
bob.Print();    // Имя: Bob  Возраст: 1 
sam.Print();    // Имя: Sam  Возраст: 25
 
struct Person
{
    public string name;
    public int age;
 
    public Person() : this("Tom")
    { }
    public Person(string name) : this(name, 1)
    { }
    public Person(string name, int age)
    {
        this.name = name;
        this.age = age;
    }
    public void Print() => Console.WriteLine($"Имя: {name}  Возраст: {age}");
}
```
Конструкторы по прежнему должны инициализировать значения всех полей, однако поскольку при вызове любого конструктора цепочка все равно закончится на последнем конструкторе, который выполняет инициализацию, то инициализацию полей в других конструкторах можно не делать. Консольный вывод программы:

```
Имя: Tom  Возраст: 1
Имя: Bob  Возраст: 1 
Имя: Sam  Возраст: 25
```

## Инициализатор структуры

Также, как и для класса, можно использовать инициализатор для создания структуры:

```Csharp
Person tom = new Person { name = "Tom", age = 22 };
 
tom.Print();    // Имя: Tom  Возраст: 22
 
struct Person
{
    public string name;
    public int age;
    public void Print() => Console.WriteLine($"Имя: {name}  Возраст: {age}");
}
```
При использовании инициализатора сначала вызывается конструктор без параметров: если мы явным образом не определили конструктор без параметров, то вызывается конструктор по умолчанию. А затем его полям присваиваются соответствующие значения.

## Копирование структуры с помощью with

Если нам необходимо скопировать в один объект структуры значения из другого с небольшими изменениями, то мы можем использовать оператор **with**:

```Csharp
Person tom = new Person { name = "Tom", age = 22 };
Person bob = tom with { name = "Bob" };
bob.Print();    // Имя: Bob  Возраст: 22
```
В данном случае объект bob получает все значения объекта tom, а затем после оператора with в фигурных скобках указывается поля со значениями, которые мы хотим изменить.

```
1) Переменные структуры хранят не ссылку на объект, а сам объект (у вас это не очевидно, хотя и можно догадаться). То есть это значимый тип, а не ссылочный.
2) Значит если одной структуре присвоить другую, то Скопируются Все Поля одной структуры в другую, а не ссылка, как было бы с классами.
3) Т.к. переменная хранит сами данные, а не ссылку на них, то доступ к полям осуществляется быстрее и есть некоторая экономия памяти.
4) Структуры не поддерживают наследование
```

# Типы значений и ссылочные типы

Ранее мы рассматривали следующие элементарные типы данных: int, byte, double, string, object и др. Также есть сложные типы: структуры, перечисления, классы. Все эти типы данных можно разделить на типы значений, еще называемые значимыми типами, (value types) и ссылочные типы (reference types). Важно понимать между ними различия.

Типы значений:

- Целочисленные типы (byte, sbyte, short, ushort, int, uint, long, ulong)

- Типы с плавающей запятой (float, double)

- Тип decimal

- Тип bool

- Тип char

- Перечисления enum

- Структуры (struct)

Ссылочные типы:

- Тип object

- Тип string

- Классы (class)

- Интерфейсы (interface)

- Делегаты (delegate)

В чем же между ними различия? Для этого надо понять организацию памяти в .NET. Здесь память делится на два типа: **стек** и **куча (heap)**. Параметры и переменные метода, которые представляют типы значений, размещают свое значение в стеке. 

Стек представляет собой структуру данных, которая растет снизу вверх: каждый новый добавляемый элемент помещается поверх предыдущего. Время жизни переменных таких типов ограничено их контекстом. 

Физически стек - это некоторая область памяти в адресном пространстве.

Когда программа только запускается на выполнение, в конце блока памяти, зарезервированного для стека устанавливается указатель стека. При помещении данных в стек указатель переустанавливается таким образом, что снова указывает на новое свободное место. При вызове каждого отдельного метода в стеке будет выделяться область памяти или фрейм стека, где будут храниться значения его параметров и переменных.

Например:

```Csharp
class Program
{
    static void Main(string[] args)
    {
        Calculate(5);
    }
 
    static void Calculate(int t)
    {
        int x = 6;
        int y = 7;
        int z = y + t;
    }
}
```

При запуске такой программы в стеке будут определяться два фрейма - для метода ```Main``` (так как он вызывается при запуске программы) и для метода ```Calculate```:

![](https://metanit.com/sharp/tutorial/pics/2.4.png)

При вызове этого метода ```Calculate``` в его фрейм в стеке будут помещаться значения ```t```, ```x```, ```y``` и ```z```. Они определяются в контексте данного метода. Когда метод отработает, область памяти, которая выделялась под стек, впоследствии может быть использована другими методами.

Причем если параметр или переменная метода представляет тип значений, то в стеке будет храниться непосредсвенное значение этого параметра или переменной. Например, в данном случае переменные и параметр метода ```Calculate``` представляют значимый тип - тип ```int```, поэтому в стеке будут храниться их числовые значения.

Ссылочные типы хранятся в куче или хипе, которую можно представить как неупорядоченный набор разнородных объектов. Физически это остальная часть памяти, которая доступна процессу.

При создании объекта ссылочного типа в стеке помещается ссылка на адрес в куче (хипе). Когда объект ссылочного типа перестает использоваться, в дело вступает автоматический сборщик мусора: он видит, что на объект в хипе нету больше ссылок, условно удаляет этот объект и очищает память - фактически помечает, что данный сегмент памяти может быть использован для хранения других данных.

Так, в частности, если мы изменим метод Calculate следующим образом:

```Csharp
static void Calculate(int t)
{
    object x = 6;
    int y = 7;
    int z = y + t;
}
```

То теперь значение переменной x будет храниться в куче, так как она представляет ссылочный тип object, а в стеке будет храниться ссылка на объект в куче.

![](https://metanit.com/sharp/tutorial/pics/2.5.png)

## Составные типы

Теперь рассмотим ситуацию, когда тип значений и ссылочный тип представляют составные типы - структуру и класс:

```Csharp
State state1 = new State(); // State - структура, ее данные размещены в стеке
Country country1 = new Country(); // Country - класс, в стек помещается ссылка на адрес в хипе
                                  // а в хипе располагаются все данные объекта country1
struct State
{
    public int x;
    public int y;
}
class Country
{
    public int x;
    public int y;
}
```

Здесь в методе Main в стеке выделяется память для объекта state1. Далее в стеке создается ссылка для объекта country1 (Country country1), а с помощью вызова конструктора с ключевым словом new выделяется место в хипе (new Country()). Ссылка в стеке для объекта country1 будет представлять адрес на место в хипе, по которому размещен данный объект..

![](https://metanit.com/sharp/tutorial/pics/2.2.png)

Таким образом, в стеке окажутся все поля структуры state1 и ссылка на объект country1 в хипе.

Но, допустим, в структуре State также определена переменная ссылочного типа Country. Где она будет хранить свое значение, если она определена в типе значений?

```Csharp
State state1 = new State();
Country country1 = new Country();
 
struct State
{
    public int x;
    public int y;
    public Country country;
    public State()
    {
        x = 0;
        y = 0;
        country = new Country();
    }
}
class Country
{
    public int x;
    public int y;
}
```
Значение переменной state1.country также будет храниться в куче, так как эта переменная представляет ссылочный тип:

![](https://metanit.com/sharp/tutorial/pics/2.62.png)

## Копирование значений

Тип данных надо учитывать при копировании значений. При присвоении данных объекту значимого типа он получает копию данных. При присвоении данных объекту ссылочного типа он получает не копию объекта, а ссылку на этот объект в хипе. Например:

```Csharp
State state1 = new State(); // Структура State
State state2 = new State();
state2.x = 1;
state2.y = 2;
state1 = state2;
state2.x = 5; // state1.x=1 по-прежнему
Console.WriteLine(state1.x); // 1
Console.WriteLine(state2.x); // 5
 
Country country1 = new Country(); // Класс Country
Country country2 = new Country();
country2.x = 1;
country2.y = 4;
country1 = country2;
country2.x = 7; // теперь и country1.x = 7, так как обе ссылки и country1 и country2 
                // указывают на один объект в хипе
Console.WriteLine(country1.x); // 7
Console.WriteLine(country2.x); // 7
```

Так как state1 - структура, то при присвоении state1 = state2 она получает копию структуры state2. А объект класса country1 при присвоении country1 = country2; получает ссылку на тот же объект, на который указывает country2. Поэтому с изменением country2, так же будет меняться и country1.

## Ссылочные типы внутри типов значений

Теперь рассмотрим более изощренный пример, когда внутри структуры у нас может быть переменная ссылочного типа, например, какого-нибудь класса:

```Csharp
State state1 = new State();
State state2 = new State();
 
state2.country = new Country();
state2.country.x = 5;
state1 = state2;
state2.country.x = 8; // теперь и state1.country.x=8, так как state1.country и state2.country
                      // указывают на один объект в хипе
Console.WriteLine(state1.country.x); // 8
Console.WriteLine(state2.country.x); // 8
 
struct State
{
    public int x;
    public int y;
    public Country country;
    public State()
    {
        x = 0;
        y = 0;
        country = new Country(); // выделение памяти для объекта Country
    }
}
class Country
{
    public int x;
    public int y;
}
```
Переменные ссылочных типов в структурах также сохраняют в стеке ссылку на объект в хипе. И при присвоении двух структур state1 = state2; структура state1 также получит ссылку на объект country в хипе. Поэтому изменение state2.country повлечет за собой также изменение state1.country.

![](https://metanit.com/sharp/tutorial/pics/2.3.png)

## Объекты классов как параметры методов

Организацию объектов в памяти следует учитывать при передаче параметров по значению и по ссылке. Если параметры методов представляют объекты классов, то использование параметров имеет некоторые особенности. Например, создадим метод, который в качестве параметра принимает объект Person:

```Csharp
Person p = new Person { name = "Tom", age = 23 };
ChangePerson(p);
 
Console.WriteLine(p.name); // Alice
Console.WriteLine(p.age); // 23
 
void ChangePerson(Person person)
{
    // сработает
    person.name = "Alice";
    // сработает только в рамках данного метода
    person = new Person { name = "Bill", age = 45 };
    Console.WriteLine(person.name); // Bill
}
 
class Person
{
    public string name = "";
    public int age;
}
```
При передаче объекта класса по значению в метод передается копия ссылки на объект. Эта копия указывает на тот же объект, что и исходная ссылка, потому мы можем изменить отдельные поля и свойства объекта, но не можем изменить сам объект. Поэтому в примере выше сработает только строка person.name = "Alice".

А другая строка person = new Person { name = "Bill", age = 45 } создаст новый объект в памяти, и person теперь будет указывать на новый объект в памяти. Даже если после этого мы его изменим, то это никак не повлияет на ссылку p в методе Main, поскольку ссылка p все еще указывает на старый объект в памяти.

Но при передаче параметра по ссылке (с помощью ключевого слова **ref**) в метод в качестве аргумента передается сама ссылка на объект в памяти. Поэтому можно изменить как поля и свойства объекта, так и сам объект:

```Csharp
Person p = new Person { name = "Tom", age = 23 };
ChangePerson(ref p);
 
Console.WriteLine(p.name); // Bill
Console.WriteLine(p.age); // 45
 
void ChangePerson(ref Person person)
{
    // сработает
    person.name = "Alice";
    // сработает
    person = new Person { name = "Bill", age = 45 };
}
 
class Person
{
    public string name = "";
    public int age;
}
```

Операция new создаст новый объект в памяти, и теперь ссылка person (она же ссылка p из метода Main) будет указывать уже на новый объект в памяти.